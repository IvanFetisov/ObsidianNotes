CAP теорема, известная также как теорема Бюрера, формулирует основное ограниченное для распределённых систем:  они не могут одновременно гарантировать три важнейших характеристики
* Согласованность данных 
* Доступность работы
* Устойчивость к сетевым сбоям
Согласно CAP-теореме, невозможно, чтобы распределенная система одновременно имела все 3 основные характеристики. 

Отсюда и аббревиатура CAP, где каждая буква обозначает одно из этих свойств
##  Что стоит за CAP
В CAP говорится, что в распределенной системе возможно выбрать только 2 из 3-х свойств. 
* **C (consistency)** - согласованность, каждое чтение даст вам последнюю запись 
* **A (Availability)** - доступность. Каждый узел(не упавший) всегда успешно выполняет запросы(на чтение и запись)
* **P (Partition tolerance)** - устойчивость к распределению. Даже если между узлами нет связи, они продолжают работать независимо друг от друга. 
## В основном это всё треугольник
![[Pasted image 20250222161528.png]]
### Применяем на практике 
Для применения CAP теоремы на практике, я выбрал 3 наиболее, на мой взгляд, подходящие и достаточно популярные системы баз данных Postgresql, MongoDB, Cassandra
#### Посмотрим на Postgresql
Следующие пункты относятся к абстрактной распределенной БД Postgresql. 
* Репликация Master-Slave - одно из распространенных решений
* Синхронизация с Master в асинхронном/синхронном режиме
* Система транзакций использует двухфазный коммит для обеспечения consistency 
* Если возникает partition, вы не можете взаимодействовать с системой (в основном случае)
Таким образом, система не может продолжать работу в случае partition, но обеспечивает strong consistency и availability. Это система СA! 
#### Посмотрим на MongoDB
Следующие пункты и относятся к абстрактной распределенной БД MongoDB.
* MongoDB  - обеспечивает strong consistency, потому что это система с одним Master узлом, и все записи идут по умолчанию в него 
* Автоматическая смена мастера. в случае его отделения его от остальных узлов
* В случае разделения сети, система прекратит принимать записи до тех пор, пока не убедится, что может безопасно завершить их
Таким образом, система может продолжать работу в случае разделения сети, но теряется CAP - availability. это CP система! 
### Посмотрим на Cassandra 
Cassandra использует схему репликации master-master, что фактически означает AP систему, в которой разделение сети приводит к самодостаточному функционированию всех узлов. Казалось бы все просто... Но это не так

## Проблемы CAP 
На тему проблем в CAP теореме написано множество подробных и интересных статей, поэтому я оставлю ссылку на [CAP больше не актуален](https://habrahabr.ru/post/258145/) и [мифы о CAP теореме](https://habrahabr.ru/post/322276/). Обязательно почитайте их, но относитесь к каждой статье, как к своего рода новому взгляду и не принимайте слишком близко к сердцу, потому что одни ругают, другие хвалят. Сам же я не буду слишком углубляться, а постараюсь выдать некоторую необходимую компиляцию.  
  
Итак, проблемы CAP теоремы:
* Далёкие от реального мира определения 
* В рамках разработки, выбор в основном лежит между CP и AP
* Множество систем - просто P 
* Чистые AP и CP системы могут быть не тем, что ожидаешь 
### Что не так с определениями? 
Consistency в CAP фактичекски означает линеаризуемость (и ее действительно трудно достичь). 
Чтобы объяснить, что такое линеаризуемость, давайте посмотрим на следующую картинку: ![[Pasted image 20250222163302.png]]
В описанном случае рефери закончил игру, но не каждый клиент получает один и тот же результат. Чтобы сделать его систему линеаризованной, нам нужно мгновенно синхронизировать данные между рефери и другими источниками данных, чтобы, когда рефери закончит игру, каждый клиент получил правильную информацию. 

Availability в CAP, исходя из определения имеет две серьёзные проблемы. Первая - нет понятия частичной доступности, или какой-то её степени (проценты например), а есть только полная доступность. Вторая проблема - неограниченное время ответа на запросы, т.е даже если система отвечает час, она еще доступна. 
Устойчивость к распределению не включает в себя упавшие узлы, и вот почему:

1. По определению. В availability так и прописано "... every node (if note failed) always..."
2. Исходя из доказательства. Доказательства CAP теоремы гласят что н а узлах должен исполняться некоторый код 
3. Ну и немного моих (и не только) домыслов. В случае падения узла, система может восстановиться, пообщаться с другими узлами и продолжить работу как ни в чем ни бывало . В случае разделения сети - придётся ждать восстановления соединения. 

Поэтому, нужно помнить про способность системы восстанавливаться, но за рамками CAP теоремы

### AP/CP выбор 
Коммуникация узлов между собой обычно происходит через асинхронную сеть, которая может задерживать или удалять сообщения. Интернет и все наши центры обработки данных обладают этим свойством, и это не маловероятные инциденты, поэтому CA системы в рамках разработки рассматривается крайне редко.

### Многие системы - просто P 
Представьте систему, в которой два узла (Master, Slave) и клиент. Если вдруг вы потеряли связь с Master, клиент может читать из Slave, но не может писать - нет CAP-availability 

Ок, вроде CP система, но не Master и Slave синхронизируются асинхронно, то клиент, может запросить данные от Slave раньше успешной синхронизации - теряем CAP - consistency 
![[Pasted image 20250222164246.png]]
### Чистые AP и CP системы
Чистые AP системы, могут включать в себя просто 2 генератора чисел. Чистые CP системы, могут вообще не быть доступны, т.к буду пытаться прийти к согласованному состоянию и не будут нам отвечать. Идём дальше, CP системы дают нам не ожидаемый нами strong consistency, а eventual consistency.  О нём говорим чуть позже.

### Как с этим жить
В конце концов, это всего лишь попытка классифицировать что-то абстрактное, поэтому вам не нужно изобретать велосипед. Я рекомендую использовать следующий подход при попытке работать с распределенными БД:
* Помните об CAP и об их ограничениях.
* Используйте теорему PACELC вместо CAP,  она позволяет взглянуть на систему еще с одного ракурса.
* Помните про принципы ACID / BASE и насколько они применимы к вашей системе.
* Любые телодвижения следует делать, учитывая проект, над которым вы работаете
Далее [[PACELC]]
